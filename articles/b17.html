<!DOCTYPE html>
<html lang="en">
<head>
<base href = "..">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="css/style.css">
<link rel="icon" type="image/x-icon" href="images/favicon.jpg">
<title>Computing on the Mind, Hayden Shuker</title>
</head>
<body>
<header>
<nav class="prime-nav">
<ul>
<li><a href="index.html">home</a></li>
<li><a href="about.html">about</a></li>
<li><a href="links.html">links</a></li>
<li><a href="archive.html">archive</a></li>
</ul>
</nav>
</header>
<main>
<article>
<heading>
<h1>Computing on the Mind</h1>
<p><time datetime='2024-07-18'>July 18, 2024</p>
</heading>
<p>What is programming like? This is me speaking from the construction of the website, its supporting tools, a bunch of <a href='https://claytondoesthings.xyz/games/arc-2/web'>little games</a> and scripts from back to the 8th grade, and ten million stupid little Matlab exercises from engineering school.</p>

<figure>
<img src='images/book-and-laptop-dithered.webp'>
<figcaption><a href='articles/b12.html'>My laptop</a> and my software notebook.</figcaption>
</figure>

<section>
<h2>Organizational chops</h2>
<p>Programming is probably the most flexible craft made by humanity. You can solve a problem in an whatever way using whatever set of abstracting tools. Any given process is easy to solve at least to a minimally functional level. That part is some tool knowledge and maybe some math chops. Any given (non-trivial) program is made of sub-processes and sub-processes and companion processes triggered between different conditions timed between each other and pointing to everything else. The hard part is the organization, comprehending all these pieces, sticking them together, keeping them inline and boiling off the redundancy until the whole thing can be a relatively cohesive unit. It feels like being the big mob boss and the little processes are your idiot goons.</p>
<p>If the problem becomes that big and zoomed out, the code just looks like colorful shapes. The idea as a whole is in plain english. Solving a problem for the first time means charts and documentation that get revised and replenished as the code does.</p>
<figure>
<img src='images/function-flowchart.webp'>
<figcaption>Nearly illegible flow charts made to work out a function for my static site builder.</figcaption>
</figure>
<p>I got good at this method from engineering class. We loved complaining about this level of formality.</p>
<figure>
<img src='images/solvem.webp'>
<figcaption>Nearly illegible flowcharts made for an engineering school matlab project. Made in microsoft word.
</figure>
<p>A lot more papers full come out of me now. Most of them these sloppy to-do lists and notes, anything to keep the structure from falling into a wash of letters and parenthesis.</p>
<figure>
<img src='images/dev-book.webp'>
<figcaption>The first page of my software notebook planning my static site builder.<figcaption>
</figure>
</section>

<section>
<h2>Losing perspective</h2>
<figure>
<img src='images/ux-flowchart.webp'>
<figcaption>Shoddy UX flow diagrams used to redesign this site.<figcaption>
</figure>

<p>Programming has a lot of craftwork and nuance, but its also the thing where principle of operation can be most separated from experience. You can’t tell how your programs work by looking at them; You don’t need to care about what a program does to work on it. They call it ‘front end’ and ‘back end’. The divorce makes two problems: programs that feel good but run like hot garbage, and programs that run good but feel like hot garbage (most web apps and most Linux apps respectively). The former is just regular consumerist wasteful <a href ='https://wiki.xxiivv.com/site/stack.html'>abundance squandering</a>. The later is ‘technologist brain’: the <a href='https://prog21.dadgum.com/128.html'>obsession with tools</a> and mechanisms, their tight inner workings with their purity and power to the extent that when we take off our navy blue jumpsuits and zoom out— we never considered what the machine does.</p>
<p>The unhelpful technologist mindset is process and paraphernalia, not for some intrinsic joy, but for a quest of abstract detached quality. These are the guys who made and bought cryptocurrency, and a similar affliction takes our Linux bro friends.</p>
<p>The blue collar is only as good as the white collar is only as good as the system is only as good as the blue collar. Their severance is doable and hideable, but not good.</p>
<p>I don’t want to be a programmer because that title seems deeply incomplete and what they do seems deeply superfluous.</p>
</section>

<section>
<h2>Computing as meditation</h2>
<p>Not just programming, but using a computer (at least a good one like mine) can be damn peaceful. I focus on pressing the keyboard with as little force as possible, I use inputs that keep my hands still and relaxed. The screen falls out of favor. Every mechanism literally happens at subvisible scale. Perception of the machine is limited to tools of the machine. The scenes become cloudy and the imagination becomes sharp, using the computer means developing a working model for what its doing. Bug fixing is bringing that model back to reality, drafting theories and sending out probes to see this untouchable object.</p>
</section>
</article>
</main>
<footer>
<article>
<nav>
<ul>
  <li><a href="mailto:contact@haydenshuker.com">email</a></li>
  <li><a href="https://www.instagram.com/hayden.shuker">instagram</a></li>
  <li><a href="rss.xml">rss</a></li>
</ul>
</nav>
</article>
</footer>
</body>
</html>
